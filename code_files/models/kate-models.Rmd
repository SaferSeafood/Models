### Library and function read in

pacman: more convenient performs tasks associated with add on packages, wraps libraries and functions

Descriptive statistics: - specifying associations that can be used to predict outcomes, associations such as interactions between variables (covariates) in order to predict DDT concentrations in fish

### A better understanding of lillians model - bayesian modelling 

```{r}
## Regress fish [DDT] against sediment [DDT]

# install and/or load the necessary R packages
if("pacman" %in% installed.packages() == FALSE){install.packages("pacman")}
pacman::p_load(geojsonR, factoextra,sf,dplyr, ggplot2, maps, fields,raster, 
               MuMIn, lubridate, tidyr,ggh4x, lme4,sdmTMB,inlabru,cowplot,
               INLAutils, marmap,sjPlot,rgeos, tidyverse, plyr, tidybayes, brms, bayesplot, loo,ggeffects,
               DHARMa, DHARMa.helpers) 


##################################################################################################################
################### Load in data and add censoring column   ###################
##################################################################################################################

# Read in sediment data 
sediment.summary = readRDS(here::here("data","sediment_data","totalDDX_sediment_zone_summary.rds")) %>%
  dplyr::select(Name, Est.2003, Est.2008, Est.2013, Est.2018) %>%  # select all years of interest
  gather(key="Year",value="TotalDDT",Est.2003:Est.2018) %>%  
  dplyr::mutate(Year = case_when(Year == "Est.2003" ~ "2003", #change est. to simply the year
                                 Year == "Est.2008" ~ "2008",
                                 Year == "Est.2013" ~ "2013",
                                 Year == "Est.2018" ~ "2018")) %>% 
  dplyr::group_by(Name, Year) %>% # group by the name and the year to do. statistics on 
  dplyr::summarize(TotalDDT.sed = (mean((TotalDDT)))) %>%
  dplyr::ungroup() 

# Read in fish life history 
fish.lh = read.csv(here::here("data","fish_data","fish_life_history.csv")) %>% 
  dplyr::mutate(species = tolower(species))

# Read in fish data, and join with sediments 
fish.reg = read.csv(here::here("data","fish_data","totalDDX_fish_southernCA.csv")) %>% # Read in fish DDT values 
  # We have sediment data blocked off by 2003, 2008, 2013, and 2018. Figure out what (continous) fish years go with which sediment years. 
  dplyr::mutate(NewYear = case_when(Year %in% c(1995:2005) ~ "2003", 
                                    Year %in% c(2006:2010) ~ "2008", 
                                    Year %in% c(2011:2015) ~ "2013", 
                                    Year %in% c(2016:2022) ~ "2018")) %>%  #join by area name and change newyear variables s
  left_join(., sediment.summary, by=c("CompositeStationArea"="Name", "NewYear"="Year")) %>% 
  dplyr::left_join(., fish.lh, by=c("CompositeCommonName"="species")) %>% 
  dplyr::mutate(feeding_position = case_when(feeding_position == "pelagic" ~ "Pelagic",
                                             feeding_position == "midwater" ~ "Midwater",
                                             feeding_position == "benthopelagic " ~ "Benthopelagic",
                                             feeding_position == "benthic" ~ "Benthic", 
                                             TRUE ~ feeding_position)) %>% 
  dplyr::mutate(feeding_position = factor(feeding_position, levels=c("Pelagic","Midwater","Benthopelagic","Benthic"))) %>% 
  dplyr::mutate(trophic_category = case_when(trophic_category == "herbivore" ~ "Herbivore",
                                             trophic_category == "primary_carnivore" ~ "Primary Carnivore",
                                             trophic_category == "secondary_carnivore" ~ "Secondary Carnivore",
                                             trophic_category == "tertiary_carnivore" ~ "Tertiary Carnivore")) 
  
# Add transformed columns (TotalDDT.lipid is already normalized by Lipid for fish)
fish.reg$TotalDDT.trans = log(fish.reg$TotalDDT.lipid + 1)
fish.reg$TotalDDT.sed.trans = log(fish.reg$TotalDDT.sed + 1)

# Add censoring for values equal to zero (so value is constrained to fall between zero and MDL)
fish.reg = fish.reg %>% 
  dplyr::mutate(Censored = ifelse(TotalDDT.trans == 0, "interval","none"), 
                Detection.Limit = ifelse(is.na(MDL.min), 0.5,log1p(MDL.min/Lipid))) %>% 
  dplyr::mutate(Year = Year - 1998) # We want to use years since 1998 
#log1p log and plus 1 because cant handlge negativ vaalu
# if DDT conc = 0 they made it a interval, if na its 0.5, and no MDL is found it set it to 0.5 
# upper is MLD> min 
# annything bellow upper is censored! 
```

#### What did data look like prior to transformations? 

```{r}
ggplot(data = fish.reg, aes(x = TotalDDT.sed, y = TotalDDT)) +
  geom_point()
```

Why log transform data? 
- chose lipid normalized concentrations due to documented positive relationship between lipid content and organic contaminant  concentrations in fish tissue 
- fish and sediment values were transormed by log where x is DDT conc. to account for right skewness and zero values
- zero values!!!
- log transformations reduce impact of outiers by compressing data range and bringing extreme values closer to the mean, skewness makings it challenging to interpret results and fit models (statistical techniques assume that data follows a normal distribution)

```{r}
ggplot(data = fish.reg, aes(x = TotalDDT.sed.trans, y = TotalDDT.trans)) +
  geom_point()
```


# Lipid nomralized: 
- normalization tries to account for bias or errors to samples more comparable and measure differences 
- we're dealing with non lipid normalzied data! makes more sense to consuemrs!!

```{r}
##################################################################################################################
################### Plot fish against sediments   ###################
##################################################################################################################

fish.reg %>% 
  dplyr::mutate(feeding_position = factor(feeding_position, levels=c("Benthic","Benthopelagic","Midwater","Pelagic"))) %>% 
  ggplot(mapping=aes(x=TotalDDT.sed.trans, y=TotalDDT.trans, fill= trophic_category )) +
  geom_jitter(size=1.5, pch=21) +
  ylab("[DDXfish] ng/g lipid") +
  xlab("[DDXsed] ng/g dw") +
  facet_wrap(~feeding_position, nrow=1)+
  scale_fill_manual(values = c("#ffffcc","#a1dab4","#41b6c4","#225ea8"), name="Diet")+
  theme_bw() +
  theme(legend.position = "none") 

# looking at this graph, benthic and bethopelgaic seems to havea. positive relationship but midwater and pegalic appear to be pretty equally distributed 

```
- use prior function to sepdiy the distributions 

```{r}
##################################################################################################################
################### Run BRMS Models   ###################
##################################################################################################################

# Look at best structure for model, in the first argument specify distribtion we want to assume four our priors, including the distribution parameters 
# in second argument, define the class of prior , mean the class in itercept since it is a fixed population level effect 
# class = b becuase its the default population level effects 
# brm packages! 
# model fit can be assued and compared with posterior predictive checks and leavev on out cross validation
# ~ splits right and lelft side of the equation
# cens generates a censored or interval version of a distribvution, provides , changes some components of distribution to help fitting process

brm.none = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans, data = fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b"))) # set priors to be 0 mean and 0.5 sd
# TotalDDT.trans is dependant variable which may be right censroed due to detection limit
#  DDT for fish was treated as a continous, left censored variable where non detected values were constrained to fall between zero and method detection limit
# mdls were variable across all six DDX analytes was selected for each fish compostie 
# mdl: minimum measured concentration of a substance that can be reported with 99% confidence that measrued concentration is distinuishable from (MDLS seet so there are non zero values),


brm.habitat.slope = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans + TotalDDT.sed.trans:feeding_position, data = fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))
# running brm, : is an interaction symbol for sediment DDT and feeding position 
# setting priors to find ability of this model sediment plus interaction between sediment and feeding position to predict habitat effects on DDT given sediment is censored and has a detection limit 


brm.habitat.intercept = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans + feeding_position, data =  fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))
# running brm for total DDT which is censored and set detection limit and how sediment concentraiton adn feeding popsition without interaction predict intercept 


brm.diet.slope = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans + TotalDDT.sed.trans:trophic_category, data =fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))
#. total DDT censored and set a detection limit to account for zero vallues, sediment plus interzction bettween trophic category adn sediment DD< priors dset


brm.diet.intercept = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans + trophic_category, data =fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))
# diet effect on Total DDT censored and set detecton ;9,ot, sediment DDT and trophic categori 

brm.trophic = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans *
                    trophic_category, 
                  data =fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))
# * used to indicate all main effects and interactions among variables that it joins  
# + only used to indicate two effects 

brm.habitat = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans * feeding_position, 
                  data =fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))

brm.diet.habitat = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans * trophic_category + 
                         TotalDDT.sed.trans * feeding_position, data =fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))
# interaction * term and 
# assisned species diet and habitat classificaitons according to life hsitory charactersitcsi 


brm.diet.habitat.year = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans * trophic_category + 
                              TotalDDT.sed.trans * feeding_position + Year, data =fish.reg, prior = c(set_prior("cauchy(0, 0.5)", class = "b")))

# two separate priors used 
brm.diet.habitat.species = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans * trophic_category + 
                                 TotalDDT.sed.trans * feeding_position  +
                                 (1|CompositeCommonName), data =fish.reg, 
                               prior = c(
                                 set_prior("cauchy(0, 0.5)", class = "b"),   
                                 set_prior("cauchy(0, 2)", class = "sd")))

brm.diet.habitat.species.year = brm(TotalDDT.trans|cens(Censored, Detection.Limit) ~ TotalDDT.sed.trans * trophic_category + 
                                      TotalDDT.sed.trans * feeding_position + Year + 
                                      (1|CompositeCommonName), data =fish.reg, 
                                    prior = c(
                                      set_prior("cauchy(0, 0.5)", class = "b"),   
                                      set_prior("cauchy(0, 2)", class = "sd")))
```

Cross Validation:  leave on out cross alidation ar methods for estimating point wise out of sample prediction accuracy from a fittd hbayesian model using log- likelidd evaludated at posterior simulations of parameter vlaues 
- loo package: 
- we obtain approx standard errorsfor estimated predictive errors and for comparing of predictive errordd between. 2 models 
- is K fold cross val, with k =n, the number of datapoints in set 
- N sdparate times function approximator is trained on all data except for point and a predicton is mde for thst point 

holdout : simplest kind of ceoss val, datet os s[;it into two cxalled testing qand training, funciton approxiamtor fits a function using training set only, then asked to predict output values for data in testing sret 
k - fold cross val: 
- data set divided into k subsets and hldout is repeated k times, each time one of k subsets is for testing and other k-1 subsets are used for training an
- average across all k trials is computed 
- every data point is in test set exaclty one and is in training set k -1 times 
- takes k times as muchc omputation tie 



```{r}
# Compare LOOIC
LOO.results = LOO(brm.none, 
                  brm.habitat.slope,brm.habitat, brm.habitat.intercept,
                  brm.diet.slope,brm.diet.intercept,brm.trophic,
                  brm.diet.habitat,brm.diet.habitat.year, 
                  brm.diet.habitat.species, brm.diet.habitat.species.year)

# Compare bayesian R2 - NOTE CENSORED MODELS HAVE ISSUES WITH INTERPRETATION OF THIS 
# lapp() applies bayesian R2 to all 


R2.results = lapply(X=list(brm.none, 
                           brm.habitat.slope,brm.habitat, brm.habitat.intercept,
                           brm.diet.slope,brm.diet.intercept,brm.trophic,
                           brm.diet.habitat,brm.diet.habitat.year, 
                           brm.diet.habitat.species, brm.diet.habitat.species.year), FUN=bayes_R2)

## Look at paramter estimates for best-fit model (80% highest density credible intervals)
# parameter estimates lwoest value is best value 

mcmc_intervals_data(brm.diet.habitat.species.year, point_est="mean",prob = 0.8, prob_outer = 1)
```

```{r}
##################################################################################################################
################### Plot posterior predictions for habitat/ diet models ###################
##################################################################################################################

# function (posterior) uses model.type 

get_dataframe_intervals <- function(model, model.type=c("trophic","habitat","all.fe")) {
  
  posterior <- as.matrix(model)
  
  if(model.type == "trophic") {levels =rev(c("Tertiary Carnivore","Secondary Carnivore","Primary Carnivore", "Baseline"))}
  else if(model.type == "habitat") {levels = rev(c("Benthic","Benthopelagic","Midwater","Baseline"))}
  else {levels = rev(c("Tertiary Carnivore","Secondary Carnivore","Primary Carnivore",
                       "Benthic","Benthopelagic","Midwater","Baseline", "Year"))}
  
  
  if(model.type %in% c("trophic","habitat","all.fe")){
    data = mcmc_intervals_data(posterior, point_est="mean",prob = 0.8, prob_outer = 1) %>% 
      dplyr::filter(grepl("b_", parameter)) %>% 
      #dplyr::filter(!parameter %in% c("sigma","lprior","lp__","sd_CompositeCommonName__Intercept")) %>% 
      dplyr::mutate(parameter_new = case_when(parameter == "b_TotalDDT.sed.trans" ~"Baseline", 
                                              parameter == "b_TotalDDT.sed.trans:feeding_positionMidwater" ~ "Midwater",
                                              parameter == "b_TotalDDT.sed.trans:feeding_positionBenthopelagic" ~ "Benthopelagic", 
                                              parameter == "b_TotalDDT.sed.trans:feeding_positionBenthic" ~ "Benthic", 
                                              parameter == "b_TotalDDT.sed.trans:trophic_categoryPrimaryCarnivore" ~ "Primary Carnivore", 
                                              parameter == "b_TotalDDT.sed.trans:trophic_categorySecondaryCarnivore" ~ "Secondary Carnivore", 
                                              parameter == "b_TotalDDT.sed.trans:trophic_categoryTertiaryCarnivore" ~ "Tertiary Carnivore", 
                                              parameter == "b_Intercept" ~ "Baseline",
                                              parameter == "b_Year" ~ "Year",
                                              parameter ==  "b_trophic_categoryPrimaryCarnivore" ~ "Primary Carnivore", 
                                              parameter == "b_trophic_categorySecondaryCarnivore" ~ "Secondary Carnivore", 
                                              parameter == "b_trophic_categoryTertiaryCarnivore" ~ "Tertiary Carnivore", 
                                              parameter == "b_feeding_positionMidwater" ~ "Midwater", 
                                              parameter == "b_feeding_positionBenthopelagic" ~ "Benthopelagic", 
                                              parameter ==  "b_feeding_positionBenthic" ~ "Benthic")) %>% 
      dplyr::mutate(type = case_when(parameter == "b_TotalDDT.sed.trans" ~"Sediment[DDT]", 
                                     parameter == "b_TotalDDT.sed.trans:feeding_positionMidwater" ~ "Sediment[DDT]",
                                     parameter == "b_TotalDDT.sed.trans:feeding_positionBenthopelagic" ~ "Sediment[DDT]", 
                                     parameter == "b_TotalDDT.sed.trans:feeding_positionBenthic" ~ "Sediment[DDT]", 
                                     parameter == "b_TotalDDT.sed.trans:trophic_categoryPrimaryCarnivore" ~ "Sediment[DDT]", 
                                     parameter == "b_TotalDDT.sed.trans:trophic_categorySecondaryCarnivore" ~ "Sediment[DDT]", 
                                     parameter == "b_TotalDDT.sed.trans:trophic_categoryTertiaryCarnivore" ~ "Sediment[DDT]", 
                                     parameter == "b_Intercept" ~ "Intercept",
                                     parameter == "b_Year" ~ "Year",
                                     parameter ==  "b_trophic_categoryPrimaryCarnivore" ~ "Intercept", 
                                     parameter == "b_trophic_categorySecondaryCarnivore" ~ "Intercept", 
                                     parameter == "b_trophic_categoryTertiaryCarnivore" ~ "Intercept", 
                                     parameter == "b_feeding_positionMidwater" ~ "Intercept", 
                                     parameter == "b_feeding_positionBenthopelagic" ~ "Intercept", 
                                     parameter ==  "b_feeding_positionBenthic" ~ "Intercept")) %>% 
      dplyr::mutate(parameter_new = factor(parameter_new, levels=levels)) 
    
  }
  else {
    data = mcmc_intervals_data(posterior, point_est="mean",prob = 0.8, prob_outer = 1) %>% 
      dplyr::mutate(type = "Intercept") %>% 
      dplyr::filter(grepl("r_", parameter)) %>% 
      dplyr::mutate(parameter_new = str_remove(parameter, c("r_CompositeCommonName"))) %>% 
      dplyr::mutate(parameter_new = str_remove(parameter_new, c(",Intercept"))) %>% 
      dplyr::mutate(parameter_new = gsub("[][()]", "", parameter_new)) %>% 
      dplyr::mutate(parameter_new = gsub("\\.", " ", parameter_new)) %>% 
      dplyr::left_join(., fish.reg[, c("CompositeCommonName","trophic_category","feeding_position")], by=c("parameter_new"="CompositeCommonName")) %>% 
      dplyr::mutate(parameter_new = factor(parameter_new, levels=(unique(fish.reg$CompositeCommonName[order(fish.reg$trophic_level)])))) %>% 
      unique()
  }
  
  return(data)
}

# mmc_intervals_data plot central posterior interval estiamtes from MCMC drawss 
```

```{r}
dummy <- data.frame(term = rep("dummy",6), 
                    type = c("Intercept","Intercept","Sediment[DDT]","Sediment[DDT]","Year","Year"), 
                    m = c(-1.25, 3.1, -0.56, 0.85, -0.15, 0.15))

null.effects = ggplot(get_dataframe_intervals(brm.none, model.type="trophic"), 
                      aes(x = m)) + 
  geom_linerange(aes(y = parameter_new, color=parameter_new,xmin = ll, xmax = hh), size=1.1, color="black")+
  geom_crossbar(aes(y = parameter_new, color=parameter_new, fill=parameter_new,xmin = l, xmax = h), width=0.2, color="black")+
  theme_bw() + 
  facet_wrap(~type, scales="free_x") + 
  geom_vline(xintercept=0, linetype="dashed") + 
  scale_color_manual(values=c("#ffffcc","#a1dab4","#41b6c4","#225ea8")) + 
  scale_fill_manual(values=c("#ffffcc","#a1dab4","#41b6c4","#225ea8")) + 
  xlab("Coefficient Estimate") + 
  ylab("") + 
  theme(legend.position = "none") + 
  ggtitle("Null Model") + 
  geom_blank(data=dummy[dummy$type != "Year",]) 


```

```{r}
diet.effects = ggplot(get_dataframe_intervals(brm.trophic, model.type="trophic"), 
                      aes(x = m)) + 
  geom_linerange(aes(y = parameter_new, color=parameter_new,xmin = ll, xmax = hh), size=1.1, color="black")+
  geom_crossbar(aes(y = parameter_new, color=parameter_new, fill=parameter_new,xmin = l, xmax = h), width=0.2, color="black")+
  theme_bw() + 
  facet_wrap(~type, scales="free_x") + 
  geom_vline(xintercept=0, linetype="dashed") + 
  scale_color_manual(values=c("#ffffcc","#a1dab4","#41b6c4","#225ea8")) + 
  scale_fill_manual(values=c("#ffffcc","#a1dab4","#41b6c4","#225ea8")) + 
  xlab("Coefficient Estimate") + 
  ylab("") + 
  theme(legend.position = "none") + 
  ggtitle("Diet Model") + 
  geom_blank(data=dummy[dummy$type != "Year",]) 
```

```{r}
habitat.effects = ggplot(get_dataframe_intervals(brm.habitat, model.type="habitat"), 
                         aes(x = m)) + 
  geom_linerange(aes(y = parameter_new, color=parameter_new,xmin = ll, xmax = hh), size=1.1, color="black")+
  geom_crossbar(aes(y = parameter_new, color=parameter_new, fill=parameter_new,xmin = l, xmax = h), width=0.2, color="black")+
  theme_bw() + 
  facet_wrap(~type, scales="free_x") + 
  geom_vline(xintercept=0, linetype="dashed") + 
  scale_color_manual(values=c("#ffffcc","#fecc5c","#fd8d3c","#e31a1c")) + 
  scale_fill_manual(values=c("#ffffcc","#fecc5c","#fd8d3c","#e31a1c")) + 
  xlab("Coefficient Estimate") + 
  ylab("") + 
  theme(legend.position = "none")+ 
  geom_blank(data=dummy[dummy$type != "Year",]) +
  ggtitle("Habitat Model")

cowplot::plot_grid(null.effects, diet.effects,habitat.effects, 
                   align = "hv",ncol = 1,  rel_heights = c(0.5, 1,1), 
                   labels=c("A","B", "C"))
```

```{r}
##################################################################################################################
################### Plot posterior predictions for best fit model ###################
##################################################################################################################

fixed.effects.plot = ggplot(get_dataframe_intervals(brm.diet.habitat.species.year, model.type="all.fe"), 
                            aes(x = m)) + 
  geom_linerange(aes(y = parameter_new, color=parameter_new,xmin = ll, xmax = hh), size=1.1, color="black")+
  geom_crossbar(aes(y = parameter_new, color=parameter_new, fill=parameter_new,xmin = l, xmax = h), width=0.2, color="black")+
  #geom_point(color="black", size=2, alpha=0.5, pch=21) + 
  theme_bw() + 
  #facet_wrap(~type, scales="free") + 
  ggforce::facet_col(vars(type), scales = 'free', space = 'free') +
  #facet_grid(rows=vars(type), scales="free", space="free_y") + 
  geom_vline(xintercept=0, linetype="dashed") + 
  scale_color_manual(values=c("#ffffcc","#ffffcc","#fecc5c","#fd8d3c","#e31a1c","#a1dab4","#41b6c4","#225ea8")) + 
  scale_fill_manual(values=c("#ffffcc","#ffffcc","#fecc5c","#fd8d3c","#e31a1c","#a1dab4","#41b6c4","#225ea8")) + 
  xlab("Coefficient Estimate") + 
  ylab("") + 
  theme(legend.position = "none")+
  geom_blank(data=dummy) 

```

```{r}
random.effects.plot = ggplot(get_dataframe_intervals(brm.diet.habitat.species.year, model.type="all.re") %>% 
                               dplyr::mutate(trophic_category = as.factor(trophic_category)) %>% 
                               unique(), 
                             aes(x = m)) + 
  geom_linerange(aes(y = parameter_new, color=trophic_category,xmin = ll, xmax = hh), size=0.9, color="black")+
  geom_crossbar(aes(y = parameter_new, color=trophic_category, fill=trophic_category,xmin = l, xmax = h), width=0.4, color="black")+
  theme_bw() + 
  facet_grid(rows=vars(feeding_position), scales="free_y", space="free_y") + 
  geom_vline(xintercept=0, linetype="dashed") + 
  scale_color_manual(values=c("#ffffcc","#a1dab4","#41b6c4","#225ea8")) + 
  scale_fill_manual(values=c("#ffffcc","#a1dab4","#41b6c4","#225ea8")) + 
  xlab("Coefficient Estimate") + 
  ylab("") + 
  theme(legend.position = "none")+
  geom_blank(data=dummy) 

cowplot::plot_grid(fixed.effects.plot,random.effects.plot, ncol = 2,  rel_heights = c(1,1), 
                   labels=c("A","B"))

```



# More notes: 
- predict() funciton: used to predict values based on the input data
- predict() predicts new values based on input data, such as the object(cass inheriting from linear odel) new data (nput data ot predict values)
- intervals type of interval calculation?
- create a mdoel, use predict to test linear_mdoel on the new data 
- fiexed effect model: special case assuming =0 meaning no between study heterogeneity all that all studies share a single true effect size 

- right vs eft censoring


## tobit model 


```{r}

```

